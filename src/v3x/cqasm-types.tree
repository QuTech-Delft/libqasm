# Implementation for the various classes representing the types of values available in cQASM 3.0
source

# Header file for the various classes representing the types of values available in cQASM 3.0
header "v3x/cqasm-types-gen.hpp"

// Include tree base classes.
include "cqasm-tree.hpp"
tree_namespace cqasm::tree

// Include primitive types.
include "v3x/cqasm-primitives.hpp"
import cqasm.v3x.primitives

// Initialization function to use to construct default values for the tree base classes and primitives
initialize_function cqasm::v3x::primitives::initialize
serdes_functions cqasm::v3x::primitives::serialize cqasm::v3x::primitives::deserialize


# Namespace for the various classes representing the types of values available in cQASM 3.0
namespace cqasm
namespace v3x
namespace types

type_base {
    size: cqasm::v3x::primitives::Int;

    # Type of a boolean.
    bool {}

    # Type of an integer (signed 64-bit).
    int {}

    # Type of a float number (IEEE double).
    float {}

    bit {}
    qubit {}

    bit_array {}
    qubit_array {}

    # Function arguments will end up resolving to a given type
    # For example: for f(2*sqrt(pi)), 2*sqrt(pi) will end up resolving to a float type
    # Gate modifiers arguments also need to end up resolving to a given type
    # The issue here is that some of these types cannot be a qubit, they have to be a gate
    # For example, for ctrl(q0, X(q1)), the second argument has to resolve to a gate type
    # Otherwise, ctrl(q0, q1) would be well formed. The same would happen with inv(q) or pow(2, q)
    gate {}

    # Measure and reset instructions do not resolve to a gate type, but they have to have a type though
    null {}
}
