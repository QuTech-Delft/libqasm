%option noinput nounput noyywrap 8bit nodefault
%option prefix="cqasm_v2"
%option yylineno
%option reentrant bison-bridge bison-locations

%{
    /**
     * \file
     * Lexer/tokenizer, generated by Flex.
     */
    #include "cqasm-v2-parser.hpp"

    //#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
    #define DEBUG(...)

    #define YY_USER_ACTION yylloc->last_column += yyleng;
    #define LOCATION_RESET \
        yylloc->first_column = 1; yylloc->first_line = 1; \
        yylloc->last_column = 1; yylloc->last_line = 1;
    #define LOCATION_LINE \
        yylloc->last_column = 1; yylloc->last_line += 1;
    #define LOCATION_STEP \
        yylloc->first_column = yylloc->last_column; \
        yylloc->first_line = yylloc->last_line;
    #define WITH_STR(TOKNAME) \
        DEBUG("Pushing %s token (%s) starting at %d:%d\n", #TOKNAME, yytext, yylloc->first_line, yylloc->first_column); \
        yylval->str = strdup(yytext); return TOKNAME
    #define WITHOUT_STR(TOKNAME) \
        DEBUG("Pushing %s token starting at %d:%d\n", #TOKNAME, yylloc->first_line, yylloc->first_column); \
        return TOKNAME
    #define OPERATOR \
        DEBUG("Pushing '%c' token starting at %d:%d\n", yytext[0], yylloc->first_line, yylloc->first_column); \
        return yytext[0]
    #define DELETE LOCATION_STEP
%}

%x MODE_MULTILINE_COMMENT
%x MODE_VERSION
%x MODE_STRING
%x MODE_JSON
%x MODE_JSON_STRING
%x MODE_UNEXPECTED_EOF

%%

%{
    LOCATION_STEP;
%}

<INITIAL>{


    /*=======================================================================*/
    /* WHITESPACE MANAGEMENT                                                 */
    /*=======================================================================*/

    /* Newlines, no functional significance (unlike cQASM 1.x) */
(\n|\r\n?)                                          LOCATION_LINE; DELETE;

    /* Gobble up comments */
#.*                                                 DELETE;
"/*"                                                BEGIN(MODE_MULTILINE_COMMENT); DELETE;
}
<MODE_MULTILINE_COMMENT>{
"*/"                                                BEGIN(INITIAL); DELETE;
(\n|\r\n?)                                          LOCATION_LINE; DELETE;
.                                                   DELETE;
<<EOF>>                                             BEGIN(MODE_UNEXPECTED_EOF); WITHOUT_STR(END_OF_FILE);
}
<INITIAL>{

    /* Gobble up whitespace */
[ \t]+                                              DELETE;


    /*=======================================================================*/
    /* VERSION STATEMENT                                                     */
    /*=======================================================================*/

    /* This is treated separately to avoid conflicts with float literals */
(cQASM)                                             BEGIN(MODE_VERSION); WITHOUT_STR(KW_VERSION);
}
<MODE_VERSION>{
(\n|\r\n?)                                          LOCATION_LINE; BEGIN(INITIAL); DELETE;
;                                                   BEGIN(INITIAL); DELETE;
[ \t]+                                              DELETE;
[0-9]+                                              WITH_STR(INT_LITERAL_DEC);
\.                                                  OPERATOR;
.                                                   WITHOUT_STR(BAD_CHARACTER);
}
<INITIAL>{


    /*=======================================================================*/
    /* KEYWORDS                                                              */
    /*=======================================================================*/

    /* Include statement */
(include)                                           WITHOUT_STR(KW_INCLUDE);

    /* Keywords for various kinds of definitions */
(template)                                          WITHOUT_STR(KW_TEMPLATE);
(parameter)                                         WITHOUT_STR(KW_PARAMETER);
(qubit)                                             WITHOUT_STR(KW_QUBIT);
(var)                                               WITHOUT_STR(KW_VAR);
(const)                                             WITHOUT_STR(KW_CONST);
(alias)                                             WITHOUT_STR(KW_ALIAS);
(function)                                          WITHOUT_STR(KW_FUNCTION);
(operator)                                          WITHOUT_STR(KW_OPERATOR);
(type)                                              WITHOUT_STR(KW_TYPE);

    /* Scope modifier keywords */
(export)                                            WITHOUT_STR(KW_EXPORT);
(global)                                            WITHOUT_STR(KW_GLOBAL);

    /* Lifetime modifier keywords */
(static)                                            WITHOUT_STR(KW_STATIC);
(future)                                            WITHOUT_STR(KW_FUTURE);

    /* Implementation style keywords */
(inline)                                            WITHOUT_STR(KW_INLINE);
(runtime)                                           WITHOUT_STR(KW_RUNTIME);
(primitive)                                         WITHOUT_STR(KW_PRIMITIVE);

    /* Conditional flow control keywords */
(cond)                                              WITHOUT_STR(KW_COND);
(if)                                                WITHOUT_STR(KW_IF);
(elif)                                              WITHOUT_STR(KW_ELIF);
(else)                                              WITHOUT_STR(KW_ELSE);
(match)                                             WITHOUT_STR(KW_MATCH);
(when)                                              WITHOUT_STR(KW_WHEN);

    /* Looping flow control keywords */
(for)                                               WITHOUT_STR(KW_FOR);
(foreach)                                           WITHOUT_STR(KW_FOREACH);
(while)                                             WITHOUT_STR(KW_WHILE);
(repeat)                                            WITHOUT_STR(KW_REPEAT);
(until)                                             WITHOUT_STR(KW_UNTIL);

    /* Keywords for special instructions */
(goto)                                              WITHOUT_STR(KW_GOTO);
(return)                                            WITHOUT_STR(KW_RETURN);
(break)                                             WITHOUT_STR(KW_BREAK);
(continue)                                          WITHOUT_STR(KW_CONTINUE);
(print)                                             WITHOUT_STR(KW_PRINT);
(abort)                                             WITHOUT_STR(KW_ABORT);
(send)                                              WITHOUT_STR(KW_SEND);
(receive)                                           WITHOUT_STR(KW_RECEIVE);
(pragma)                                            WITHOUT_STR(KW_PRAGMA);

    /* For transposed index notation */
(transpose)                                         WITHOUT_STR(KW_TRANSPOSE);

    /*=======================================================================*/
    /* NUMERIC LITERALS                                                      */
    /*=======================================================================*/

    /* Integer literals */
[0-9][0-9_]*                                        WITH_STR(INT_LITERAL_DEC);
0x[0-9a-fA-F_]+                                     WITH_STR(INT_LITERAL_HEX);
0b[01_]+                                            WITH_STR(INT_LITERAL_BIN);

    /* Real-number literals */
([0-9][0-9_]*)?\.[0-9][0-9_]*([eE][-+]?[0-9]+)?     WITH_STR(REAL_LITERAL);

    /* Any digit followed by a letter not detected by the above is an invalid number */
[0-9][ac-wyzA-Z0-9]                                 WITHOUT_STR(BAD_NUMBER);


    /*=======================================================================*/
    /* STRING LITERALS                                                       */
    /*=======================================================================*/

["]                                                 BEGIN(MODE_STRING); WITHOUT_STR(STRING_OPEN);
}
<MODE_STRING>{
["]                                                 BEGIN(INITIAL); WITHOUT_STR(STRING_CLOSE);
[\\][tn'"\\]                                        WITH_STR(STRBUILD_ESCAPE);
[\\](\n|\r\n?)                                      LOCATION_LINE; DELETE;
(\n|\r\n?)                                          LOCATION_LINE; WITH_STR(STRBUILD_APPEND);
.                                                   WITH_STR(STRBUILD_APPEND);
<<EOF>>                                             BEGIN(MODE_UNEXPECTED_EOF); WITHOUT_STR(END_OF_FILE);
}
<INITIAL>{


    /*=======================================================================*/
    /* JSON LITERALS                                                         */
    /*=======================================================================*/

"{|"                                                BEGIN(MODE_JSON); WITHOUT_STR(JSON_OPEN);
}
<MODE_JSON>{
"|}"                                                BEGIN(INITIAL); WITHOUT_STR(JSON_CLOSE);
["]                                                 BEGIN(MODE_JSON_STRING); WITH_STR(STRBUILD_APPEND);
(\n|\r\n?)                                          LOCATION_LINE; WITH_STR(STRBUILD_APPEND);
.                                                   WITH_STR(STRBUILD_APPEND);
<<EOF>>                                             BEGIN(MODE_UNEXPECTED_EOF); WITHOUT_STR(END_OF_FILE);
}
<MODE_JSON_STRING>{
["]                                                 BEGIN(MODE_JSON); WITH_STR(STRBUILD_APPEND);
[\\].                                               WITH_STR(STRBUILD_APPEND);
(\n|\r\n?)                                          LOCATION_LINE; WITH_STR(STRBUILD_APPEND);
.                                                   WITH_STR(STRBUILD_APPEND);
<<EOF>>                                             BEGIN(MODE_UNEXPECTED_EOF); WITHOUT_STR(END_OF_FILE);
}
<INITIAL>{


    /*=======================================================================*/
    /* IDENTIFIERS                                                           */
    /*=======================================================================*/

[a-zA-Z_][a-zA-Z0-9_]*                              WITH_STR(IDENTIFIER);


    /*=======================================================================*/
    /* OPERATORS                                                             */
    /*=======================================================================*/

[()[\]{}|+\-*/=:;,.@!~<>&|^?%]                      OPERATOR;
"*="                                                WITHOUT_STR(MULTIPLY_BY);
"**"                                                WITHOUT_STR(POWER);
"**="                                               WITHOUT_STR(POWER_BY);
"/="                                                WITHOUT_STR(DIVIDE_BY);
"//"                                                WITHOUT_STR(INT_DIV);
"//="                                               WITHOUT_STR(INT_DIV_BY);
"%="                                                WITHOUT_STR(MODULO_BY);
"+="                                                WITHOUT_STR(INCREMENT_BY);
"++"                                                WITHOUT_STR(INCREMENT);
"-="                                                WITHOUT_STR(DECREMENT_BY);
"--"                                                WITHOUT_STR(DECREMENT);
">="                                                WITHOUT_STR(CMP_GE);
">>"                                                WITHOUT_STR(ARITH_SHR);
">>="                                               WITHOUT_STR(ARITH_SHR_BY);
">>>"                                               WITHOUT_STR(LOGIC_SHR);
">>>="                                              WITHOUT_STR(LOGIC_SHR_BY);
"<="                                                WITHOUT_STR(CMP_LE);
"<<"                                                WITHOUT_STR(SHL);
"<<="                                               WITHOUT_STR(SHL_BY);
"=="                                                WITHOUT_STR(CMP_EQ);
"!="                                                WITHOUT_STR(CMP_NE);
"&="                                                WITHOUT_STR(BITWISE_AND_BY);
"&&"                                                WITHOUT_STR(LOGIC_AND);
"^="                                                WITHOUT_STR(BITWISE_XOR_BY);
"^^"                                                WITHOUT_STR(LOGIC_XOR);
"|="                                                WITHOUT_STR(BITWISE_OR_BY);
"||"                                                WITHOUT_STR(LOGIC_OR);
".."                                                WITHOUT_STR(RANGE);
"->"                                                WITHOUT_STR(ARROW);


    /*=======================================================================*/
    /* DEFAULT                                                               */
    /*=======================================================================*/

    /* Catch any other character as a single-character lexeme */
.                                                   WITHOUT_STR(BAD_CHARACTER);


}
<MODE_UNEXPECTED_EOF>{
(\n|\r\n?)                                          LOCATION_LINE; DELETE;
.                                                   DELETE;
}
