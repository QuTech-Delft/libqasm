{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>libQASM is a library to parse cQASM programs, developed by QuTech.</p> <p>At the moment, libQASM only supports cQASM v3.0 programs (see cQASM-spec for the language specification).</p> <p>It performs lexical, syntactic, and semantic analysis of an input program received via a file or a string. It produces one of the following results:</p> <ul> <li>A syntactic or semantic AST (Abstract Syntax Tree) object. Depending on if we are parsing or analysing.</li> <li>A list of parsing or analysing errors. In case the input program was malformed.</li> <li>A JSON representation of either the AST or the list of errors.</li> </ul> <p>It can be used from:</p> <ul> <li>C++ projects (as a Conan package).</li> <li>Python projects (as a Python package).</li> <li>Emscripten projects (via a Typescript frontend).</li> </ul> <p>Check out QX simulator and OpenSquirrel compiler for an example of use in a C++ and a Python project, respectively.</p>"},{"location":"about/authors.html","title":"Authors","text":"<p>libQASM is developed as part of the Quantum Inspire project: support@quantum-inspire.com</p>"},{"location":"about/contributing.html","title":"Contributing","text":"<p>Contributions are what make the open source community such an amazing place to learn, inspire, and create. Any contributions you make are greatly appreciated.</p> <p>If you have a suggestion that would make this better, please fork the repo and create a pull request.</p> <ol> <li>Fork the project.</li> <li>Create your feature branch (<code>git checkout -b feature/AmazingFeature</code>).</li> <li>Commit your changes (<code>git commit -m 'Add some AmazingFeature'</code>).</li> <li>Push to the branch (<code>git push origin feature/AmazingFeature</code>).</li> <li>Open a pull request.</li> </ol>"},{"location":"about/license.html","title":"License","text":"<p>libQASM is licensed under the Apache License, Version 2.0. See LICENSE for the full license text.</p>"},{"location":"about/release-notes.html","title":"Release Notes","text":"<p>Coming soon</p>"},{"location":"api/cpp.html","title":"C++","text":"<p>libQASM C++ API is defined in <code>include/v3x/cqasm_python.hpp</code>.</p> <p>The only exported class is <code>V3xAnalyzer</code>. This is actually a C++ class that works as a binding for accessing C++ code from Python.</p> <pre><code>class V3xAnalyzer;</code></pre> <p>Main class for parsing and analyzing cQASM v3.0 files.</p> <p>This class works as a binding for accessing C++ code from Python.</p> <p>The parsing methods are static because they do not change the status of the analyzer. Instead, they just invoke free functions that create a temporary instance of a parser.</p> <p>None of the parsing or the analyzing methods perform any version check.</p> <p><code>parse_file</code>, <code>parse_string</code>, <code>analyze_file</code>, and <code>analyze_string</code>:</p> <p><ul> <li><p>Return a vector of strings. The first string is reserved for the CBOR serialization of the syntactic/semantic (in the case of parsing/analyzing) Abstract Syntax Tree (AST) of the input program. Any additional strings represent error messages. Notice that the AST and error messages will not be available at the same time.</p> </li></ul> </p> <p><code>parse_file_to_json</code>, <code>parse_string_to_json</code>, <code>analyze_file_to_json</code>, and <code>analyze_string_to_json</code>:</p> <p><ul> <li><p>Return a string in JSON format. If the parsing was successful, that string contains a JSON representation of the AST of the input program. Otherwise, it will contain a list of errors. The JSON representation of each error follows the Language Server Protocol (LSP) specification. Every error is mapped to an LSP Diagnostic structure: <code>severity</code> is hardcoded to 1 at the moment (value corresponding to an Error level).</p> </li></ul> </p> <p><code>parse_string</code>, <code>parse_string_to_json</code>, <code>analyze_string, and</code>analyze_string_to_json`:</p> <p><ul> <li><p>have an optional second argument: <code>file_name</code>. It is only used when reporting errors.</p> </li></ul> </p> <p>Example: <pre><code>auto result = analyze_file(\"grover.cq\");\n</code></pre> Example: <pre><code>auto program = std::string{ R\"(\n    version 3.0\n    qubit[2] q\n    bit[2] b\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n)\" };\nauto result = parse_string_to_json(program, \"bell.cq\");\n</code></pre> </p> <pre><code>static std::vector&lt;std::string&gt; parse_file(const std::string&amp; file_name);</code></pre> <p>Parses a file containing a cQASM v3.0 program. </p> <pre><code>static std::string parse_file_to_json(const std::string&amp; file_name);</code></pre> <p>Parses a file containing a cQASM v3.0 program. </p> <pre><code>static std::vector&lt;std::string&gt; parse_string(const std::string&amp; data, const std::string&amp; file_name);</code></pre> <p>Parses a string containing a cQASM v3.0 program.</p> <p><code>file_name</code> is optional. It is only used when reporting errors. </p> <pre><code>static std::string parse_string_to_json(const std::string&amp; data, const std::string&amp; file_name);</code></pre> <p>Parses a string containing a cQASM v3.0 program.</p> <p><code>file_name</code> is optional. It is only used when reporting errors. </p> <pre><code>V3xAnalyzer(const std::string&amp; max_version, bool without_defaults);</code></pre> <p>Creates a new cQASM v3.0 semantic analyzer.</p> <p><code>max_version</code> is optional. It has a default value of <code>3.0</code>. The maximum cQASM version supported by the analyzer.</p> <p><code>without_defaults</code> is optional. If set, the default instruction set is not loaded into the instruction table, so you have to specify the entire instruction set using <code>register_instruction()</code>. Otherwise, those functions only add to the defaults.</p> <p>The initial mappings and functions are not configurable. The defaults for these are always used. </p> <pre><code>~V3xAnalyzer();</code></pre> <p>Default destructor. </p> <pre><code>void register_instruction(const std::string&amp; name, const std::optional&lt;std::string&gt;&amp; param_types);</code></pre> <p>Registers an instruction type.</p> <p>The <code>param_types</code> can be:<ul> <li><p><code>Q</code> = qubit.</p> </li><li><p><code>V</code> = qubit array.</p> </li><li><p><code>B</code> = bit.</p> </li><li><p><code>W</code> = bit array.</p> </li><li><p><code>i</code> = int.</p> </li><li><p><code>f</code> = float.</p> </li></ul> </p> <p>Example: <pre><code>register_instruction(\"H\", \"Q\");\n</code></pre> </p> <pre><code>std::vector&lt;std::string&gt; analyze_file(const std::string&amp; file_name);</code></pre> <p>Parses and analyzes a file containing a cQASM v3.0 program. </p> <pre><code>std::string analyze_file_to_json(const std::string&amp; file_name);</code></pre> <p>Parses and analyzes a file containing a cQASM v3.0 program. </p> <pre><code>std::vector&lt;std::string&gt; analyze_string(const std::string&amp; data, const std::string&amp; file_name);</code></pre> <p>Parses and analyzes a string containing a cQASM v3.0 program.</p> <p><code>file_name</code> is optional. It is only used when reporting errors. </p> <pre><code>std::string analyze_string_to_json(const std::string&amp; data, const std::string&amp; file_name);</code></pre> <p>Parses and analyzes a string containing a cQASM v3.0 program.</p> <p><code>file_name</code> is optional. It is only used when reporting errors. </p>"},{"location":"api/emscripten.html","title":"Emscripten","text":"<p>libQASM is also deployed as an Emscripten binary with a Typescript frontend.</p> <p>libQASM Typescript API is defined in <code>emscripten/emscripten_wrapper.hpp</code>.</p> <p>The only exported class is <code>EmscriptenWrapper</code>. This is actually a C++ class that works as a binding for accessing C++ code from Typescript.</p> <pre><code>struct EmscriptenWrapper;</code></pre> <p>Main class for parsing and analyzing cQASM files.</p> <p>This class works as a binding for accessing C++ code from Typescript.</p> <p>Example: <pre><code>import { default as wrapper } from 'cqasm_emscripten.mjs';\n\nwrapper().then(function(result: any) {\n    let cqasm = new result[\"EmscriptenWrapper\"]()\n    let program = ...\n    let output = cqasm.parse_string_to_json(program, ...)\n    cqasm.delete()\n}).catch((error: any) =&gt; {\n    console.error(\"unhandledRejection\", error, \"\\n\");\n});\n</code></pre> </p> <pre><code>std::string get_version();</code></pre> <p>Returns the version of the <code>libqasm</code> library.</p> <p>Example: <pre><code>let version = cqasm.get_version()\n</code></pre> </p> <pre><code>std::string parse_string_to_json(const std::string&amp; data, const std::string&amp; file_name);</code></pre> <p>Parses a string containing a cQASM v3.0 program.</p> <p>No version check is performed.</p> <p>The <code>file_name</code> is only used when reporting errors.</p> <p>Returns a string. If the parsing was successful, the string contains a syntactic Abstract Syntax Tree (AST). Otherwise, it will contain a list of errors. The JSON representation of each error follows the Language Server Protocol (LSP) specification. Every error is mapped to an LSP Diagnostic structure: <code>severity</code> is hardcoded to 1 at the moment (value corresponding to an Error level).</p> <p>Example: <pre><code>let program = `\n    version 3\n    qubit[2] q\n    bit[2] b\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n`\nlet output = parse_string_to_json(program, \"bell.cq\")\n</code></pre> </p> <pre><code>std::string analyze_string_to_json(const std::string&amp; data, const std::string&amp; file_name);</code></pre> <p>Parses and analyzes a string containing a cQASM v3.0 program.</p> <p>No version check is performed.</p> <p>The <code>file_name</code> is only used when reporting errors.</p> <p>Returns a string. If the parsing was successful, the string contains a semantic Abstract Syntax Tree (AST). Otherwise, it will contain a list of errors. The JSON representation of each error follows the Language Server Protocol (LSP) specification. Every error is mapped to an LSP Diagnostic structure: <code>severity</code> is hardcoded to 1 at the moment (value corresponding to an Error level).</p> <p>Example: <pre><code>let program = `\n    version 3\n    qubit[2] q\n    bit[2] b\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n`\nlet output = analyze_string_to_json(program, \"bell.cq\")\n</code></pre> </p>"},{"location":"api/python.html","title":"Python","text":"<p>libQASM Python API is defined in <code>python/module/cqasm/v3x/__init__.py</code>.</p> <p>The only exported class is <code>Analyzer</code>. This is actually a Python class that works as a binding for accessing C++ code from Python.</p> <pre><code>class Analyzer</code></pre> <p>Main class for parsing and analyzing cQASM v3.0 files. </p> <p>This class works as a binding for accessing C++ code from Python.</p> <p>The parsing methods are static because they do not change the status of the analyzer. Instead, they just invoke free functions that create a temporary instance of a parser.</p> <p>None of the parsing or the analyzing methods perform any version check.</p> <p><code>parse_file</code>, <code>parse_string</code>, <code>analyze_file</code>, and <code>analyze_string</code>:</p> <p><ul> <li><p>return a vector of strings. If the length of the vector is 1, the string is a serialization of the syntactic/semantic (in the case of parsing/analyzing) Abstract Syntax Tree (AST) of the input program. Otherwise, it is a list of errors.</p> </li></ul> </p> <p><code>parse_file_to_json</code>, <code>parse_string_to_json</code>, <code>analyze_file_to_json</code>, and <code>analyze_string_to_json</code>:</p> <p><ul> <li><p>return a string in JSON format. If the parsing was successful, the string contains a JSON representation of the AST of the input program. Otherwise, it will contain a list of errors. The JSON representation of each error follows the Language Server Protocol (LSP) specification. Every error is mapped to an LSP Diagnostic structure: <code>severity</code> is hardcoded to 1 at the moment (value corresponding to an Error level).</p> </li></ul> </p> <p><code>parse_string</code>, <code>parse_string_to_json</code>, <code>analyze_string, and</code>analyze_string_to_json`:</p> <p><ul> <li><p>have an optional second argument: <code>file_name</code>. It is only used when reporting errors.</p> </li></ul> </p> <p>Example: <pre><code>result = libqasm.analyze_file(\"grover.cq\")\n</code></pre> Example: <pre><code>program = r'''\n    version 3.0\n    qubit[2] q\n    bit[2] b\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n'''\nresult = libqasm.parse_string_to_json(program, \"bell.cq\")\n</code></pre> </p> <pre><code>@staticmethod\nparse_file(*args) -&gt; list[str]:</code></pre> <p>Parses a file containing a cQASM v3.0 program. </p> <pre><code>@staticmethod\nparse_file_to_json(*args) -&gt; str:</code></pre> <p>Parses a file containing a cQASM v3.0 program. </p> <pre><code>@staticmethod\nparse_string(*args) -&gt; list[str]:</code></pre> <p>Parses a string containing a cQASM v3.0 program. </p> <pre><code>@staticmethod\nparse_string_to_json(*args) -&gt; str:</code></pre> <p>Parses a string containing a cQASM v3.0 program. </p> <pre><code>analyze_file(self, *args) -&gt; list[str]:</code></pre> <p>Parses and analyzes a file containing a cQASM v3.0 program. </p> <pre><code>analyze_file_to_json(self, *args) -&gt; str:</code></pre> <p>Parses and analyzes a file containing a cQASM v3.0 program. </p> <pre><code>analyze_string(self, *args) -&gt; list[str]:</code></pre> <p>Parses and analyzes a string containing a cQASM v3.0 program. </p> <pre><code>analyze_string_to_json(self, *args) -&gt; str:</code></pre> <p>Parses and analyzes a string containing a cQASM v3.0 program. </p>"},{"location":"dev-guide/cpp.html","title":"C++","text":"<p>You can build the C++ binaries from the project's root directory. The following line will also build and cache the <code>libqasm</code> Conan package.</p> <p>Note</p> <p>You may need to execute the <code>conan profile detect</code> command if this is the first time you run Conan.</p> <pre><code>conan profile detect\nconan create --version 0.6.9 . -pr:a=tests-debug -b missing\n</code></pre> <p>You can test the C++ binaries:</p> <pre><code>cd test/Debug\nctest -C Debug --output-on-failure\n</code></pre>"},{"location":"dev-guide/dev-guide.html","title":"Dev Guide","text":""},{"location":"dev-guide/dev-guide.html#file-organization","title":"File organization","text":"<p>For development, see:</p> <ul> <li><code>include/libqasm</code>: public headers.</li> <li><code>src</code>: source files.</li> <li><code>test</code>: test files.</li> <li><code>python</code>: SWIG interface.</li> <li><code>res</code>: resource files, for testing.</li> </ul> <p>For build process, continuous integration, and documentation:</p> <ul> <li><code>conan</code>: Conan profiles.</li> <li><code>emscripten</code>: bindings and test for the Emscripten binaries.</li> <li><code>scripts</code>: helper scripts used during the build process.</li> <li><code>.github</code>: GitHub Actions configuration files.</li> <li><code>doc</code>: documentation.</li> </ul> <p>Build outputs may go into:</p> <ul> <li><code>build/&lt;build type&gt;</code>: the C++ library output files generated by Conan.</li> <li><code>pybuild</code>: the Python library output files generated by <code>setup.py</code>.</li> </ul>"},{"location":"dev-guide/dev-guide.html#dependencies","title":"Dependencies","text":"<ul> <li>C++ compiler with C++20 support (gcc 11, clang 14, msvc 17)</li> <li><code>CMake</code> &gt;= 3.12</li> <li><code>git</code></li> <li><code>Python</code> 3.x plus <code>pip</code>, with the following package:<ul> <li><code>conan</code> &gt;= 2.0</li> </ul> </li> <li><code>SWIG</code></li> </ul>"},{"location":"dev-guide/dev-guide.html#arm-builds","title":"ARM builds","text":"<p>We are having problems when using the <code>zulu-openjdk</code> Conan package on an ARMv8 architecture. <code>zulu-openjdk</code> provides the Java JRE required by the ANTLR generator. For the time being, we install Java manually for this platform.</p> <ul> <li><code>Java JRE</code> &gt;= 11</li> </ul>"},{"location":"dev-guide/dev-guide.html#documentation","title":"Documentation","text":"<ul> <li><code>doxygen</code></li> <li><code>mkdocs</code> with the following packages:<ul> <li><code>mike</code> </li> <li><code>mkdocs-material</code></li> <li><code>mkdocstrings</code></li> <li><code>pymdown-extensions</code></li> </ul> </li> </ul>"},{"location":"dev-guide/dev-guide.html#linters","title":"Linters","text":"<ul> <li><code>clang-format-18</code></li> <li><code>clang-tidy-18</code></li> </ul> <p>On a Linux machine, these linters can be installed with the following commands:</p> <pre><code>wget https://apt.llvm.org/llvm.sh -O llvm_install.sh\nchmod +x llvm_install.sh\n./llvm_install.sh\napt-get install -y clang-format-18 clang-tidy-18\n</code></pre>"},{"location":"dev-guide/dev-guide.html#build","title":"Build","text":"<p>This version of libQASM can only be compiled via the Conan package manager. You will need to create a default profile before using it for the first time.</p> <p>The installation of dependencies, as well as the compilation, can be done in one go.</p> <pre><code>git clone https://github.com/QuTech-Delft/libqasm.git\ncd libqasm\nconan profile detect\nconan build . -pr:a=conan/profiles/tests-debug -b missing\n</code></pre> <p>Note</p> <ul> <li>the <code>conan profile</code> command only has to be run only once, and not before every build.</li> <li>the <code>conan build</code> command is building libQASM in Debug mode with tests using the <code>tests-debug</code> profile.</li> <li>the <code>-b missing</code> parameter asks <code>conan</code> to build packages from sources   in case it cannot find the binary packages for the current configuration (platform, OS, compiler, build type...).</li> </ul>"},{"location":"dev-guide/dev-guide.html#profiles","title":"Profiles","text":"<p>A group of predefined profiles is provided under the <code>conan/profiles</code> folder. They follow the <code>[tests-](build_type)(-compiler)(-os)(-arch)[-shared]</code> naming convention:</p> <ul> <li><code>tests</code>: if tests are being built.</li> <li><code>build_type</code>: can be <code>debug</code> or <code>release</code>.</li> <li><code>compiler</code>: <code>apple-clang</code>, <code>clang</code>, <code>gcc</code>, <code>msvc</code>.</li> <li><code>os</code>: <code>emscripten</code>, <code>linux</code>, <code>macos</code>, <code>windows</code>.</li> <li><code>arch</code>: <code>arm64</code>, <code>wasm</code>, <code>x64</code>.</li> <li><code>shared</code>: if the library is being built in shared mode.</li> </ul> <p>All the profiles set the C++ standard to 20. All the <code>tests</code>, except for <code>linux-x64</code> profiles, enable Address Sanitizer.</p>"},{"location":"dev-guide/dev-guide.html#options","title":"Options","text":"<p>Profiles are a shorthand for command line options. The command above could be written, similarly, as:</p> <pre><code>conan build . -s:a compiler.cppstd=20 -s:a libqasm/*:build_type=Debug -o libqasm/*:asan_enabled=True -c tools.build:skip_test=False -b missing\n</code></pre> <p>This is the list of options that could be specified either in a profile or in the command line:</p> <ul> <li><code>libqasm/*:asan_enabled={True,False}</code>: enables Address Sanitizer.</li> <li><code>libqasm/*:build_type={Debug,Release}</code>: builds in Debug or Release mode.</li> <li><code>libqasm/*:shared={True,False}</code>: builds a shared object library instead of a static library, if applicable.</li> </ul> <p>Tests are disabled by default. To enable them, use <code>-c tools.build:skip_test=False</code>.</p>"},{"location":"dev-guide/dev-guide.html#documentation_1","title":"Documentation","text":"<p>Build and serve on <code>http://127.0.0.1:8000/</code>.</p> <pre><code>export PYTHONPATH=./scripts/python\nmkdocs serve\n</code></pre> <p>Note</p> <p>The <code>export</code> is needed to point <code>mkdocs</code> to the custom handlers used for the C++, emscripten, and Python APIs.</p>"},{"location":"dev-guide/dev-guide.html#linters_1","title":"Linters","text":"<p>Continuous Integration will fail if the files do not adhere to a series of formatting and code style guidelines:</p> <ul> <li>Formatting checks are defined in <code>.clang-format</code>.</li> <li>Code style checks are defined in <code>.clang-tidy</code>.</li> </ul> <p>It is recommended to run these linters before pushing any change:</p> <pre><code>conan build . -pr:a=conan/profiles/tests-release-gcc-linux-x64 -b missing\npython3 ./scripts/run_cpp_linters.py .\n</code></pre> <p>Note</p> <ul> <li>The linters require<code>clang-format-18</code> and <code>clang-tidy-18</code>. </li> <li>It is mandatory to have a build before running the linters.<ul> <li><code>clang-tidy</code> expects to find a <code>compile_commands.json</code> in a build folder.</li> </ul> </li> <li>It is recommended to build with gcc in Release mode.<ul> <li>We have observed <code>clang-tidy</code> fails to find some standard headers when compiling with clang.</li> <li><code>run_cpp_linters.py</code> can receive a build folder as second argument, but defaults to <code>build/Release</code>.</li> </ul> </li> </ul>"},{"location":"dev-guide/dev-guide.html#docker","title":"Docker","text":"<p>This tests the library in a container with the bare minimum requirements for libQASM.</p> <pre><code>docker build .\n</code></pre> <p>Note</p> <p>The above might fail on Windows due to the <code>autocrlf</code> transformation that git does. If you run into this issue, then create new clone of this repository:</p> <pre><code>git clone --config core.autocrlf=input git@github.com:QuTech-Delft/libqasm.git\n</code></pre>"},{"location":"dev-guide/emscripten.html","title":"Emscripten","text":"<p>You can build the Emscripten binaries from the project's root directory. The generation of Emscripten binaries has been tested as a cross-compilation from an ubuntu/x64 platform.</p> <pre><code>conan build . -pr=conan/profiles/release-clang-emscripten-wasm -pr:b=conan/profiles/release -b missing\n</code></pre> <p>The output of this build lives in <code>build/Release/emscripten</code>:</p> <ul> <li><code>cqasm_emscripten.js</code>.</li> <li><code>cqasm_emscripten.wasm</code>.</li> </ul> <p>Note</p> <p><code>cqasm_emscripten.js</code> is an ES6 module. Its extension has to be renamed to <code>.mjs</code> before using it from Typescript code.</p> <p>You can test the Emscripten binaries:</p> <pre><code>cd build/Release/emscripten\nmv cqasm_emscripten.js cqasm_emscripten.mjs\ncd ../../../emscripten\ndeno run -A test_libqasm.ts\n</code></pre>"},{"location":"dev-guide/python.html","title":"Python","text":"<p>You can build and install the Python package from the project's root directory.</p> <pre><code>python3 -m pip install --verbose .\n</code></pre> <p>You can test the Python package:</p> <pre><code>python3 -m pytest\n</code></pre>"},{"location":"user-guide/cpp.html","title":"C++","text":"<p>libQASM can be requested as a Conan package from a <code>conanfile.py</code>:</p> <pre><code>def build_requirements(self):\n    self.tool_requires(\"libqasm/0.6.9\")\ndef requirements(self):\n    self.requires(\"libqasm/0.6.9\")\n</code></pre> <p>And then linked against from a <code>CMakeLists.txt</code>:</p> <pre><code>target_link_libraries(&lt;your target&gt; PUBLIC libqasm::libqasm)\n</code></pre> <p>Note</p> <p>You will need to have <code>Java JRE</code> &gt;= 11 installed in case Conan needs to build libQASM.</p> <p>And used from a C++ program:</p> <pre><code>#include \"libqasm/v3x/cqasm_python.hpp\"\n\nauto program = std::string{ R\"(\n    version 3.0\n    qubit[2] q\n    bit[2] b\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n)\" };\n\nauto parse_result = V3xAnalyzer::parse_string(program);\n\nauto analyzer = V3xAnalyzer();\nauto analysis_result = analyzer.analyze_string(program);\n</code></pre>"},{"location":"user-guide/docker.html","title":"Docker","text":"<p>libQASM can be tested in a container with the bare minimum requirements.</p> <pre><code>docker build .\n</code></pre> <p>Note</p> <p>The above might fail on Windows due to the <code>autocrlf</code> transformation that git does. If you are having trouble with this just create new clone of this repository using:</p> <p><code>git clone --config core.autocrlf=input git@github.com:QuTech-Delft/libqasm.git</code></p>"},{"location":"user-guide/emscripten.html","title":"Emscripten","text":"<p>libQASM can be used from a web environment via a Typescript frontend.</p> <p>Emscripten API only allows to input a cQASM program via a string and always returns a JSON string output. </p> <pre><code>import { default as wrapper } from 'cqasm_emscripten.mjs';\n\nwrapper().then(function(result: any) {\n    let cqasm = new result[\"EmscriptenWrapper\"]()\n    let program = `version 3.0        \n                   qubit[2] q \n                   bit[2] b        \n                   H q[0]\n                   CNOT q[0], q[1]\n                   b = measure q`\n    let output = cqasm.parse_string_to_json(program, \"bell.cq\")\n    cqasm.delete()\n}).catch((error: any) =&gt; {\n    console.error(\"unhandledRejection\", error, \"\\n\");\n});\n</code></pre>"},{"location":"user-guide/python.html","title":"Python","text":"<p>libQASM can be installed as a Python package:</p> <pre><code>pip install libqasm\n</code></pre> <p>And then imported from a Python program:</p> <pre><code>from libqasm import Analyzer\n\nprogram = r'''\n    version 3.0\n    qubit[2] q\n    bit[2] b\n    H q[0]\n    CNOT q[0], q[1]\n    b = measure q\n'''\n\nparse_result = Analyzer.parse_string(program, \"bell.cq\")\n\nanalyzer = Analyzer()\nanalysis_result = analyzer.analyze_string(program, \"bell.cq\")\n</code></pre>"},{"location":"user-guide/user-guide.html","title":"User Guide","text":"<p>libQASM can be used from:</p> <ul> <li>C++ projects (as a Conan package).</li> <li>Python projects (as a Python package).</li> <li>Emscripten projects (via a Typescript frontend).</li> <li>Docker.</li> </ul>"}]}